// @ts-check
import fs from 'fs/promises'
import path from 'path'

const APP_DIR = './src/app'
const ROUTE_FILES = ['page.tsx', 'route.ts']
const OUTPUT_FILE = './src/shared/routes.generated.ts'

export async function scanDirectory(dir) {
  const entries = await fs.readdir(dir)
  const routes = []

  for (const entry of entries) {
    const fullPath = path.join(dir, entry)
    const stats = await fs.stat(fullPath)

    if (stats.isDirectory()) {
      // Пропускаем служебные папки
      if (entry.startsWith('_')) continue

      // Рекурсивно сканируем поддиректории
      const subRoutes = await scanDirectory(fullPath)
      routes.push(...subRoutes)
    } else if (ROUTE_FILES.includes(entry)) {
      // Преобразуем путь файла в маршрут
      const relativePath = path.relative(APP_DIR, dir)
      const route = convertPathToRoute(relativePath)
      routes.push(route)
    }
  }

  return routes
}

export function convertPathToRoute(path) {
  // Удаляем скобки и их содержимое
  path = path.replace(/\([^)]*\)/g, '')

  // Заменяем опциональные catch-all параметры
  path = path.replace(/\[\[\.\.\.([^\]]+)\]\]/g, '[...$1]?')

  // Заменяем обычные catch-all параметры
  path = path.replace(/\[\.\.\.([^\]]+)\]/g, '[...$1]')

  // Заменяем динамические параметры
  path = path.replace(/\[([^\]]+)\]/g, ':$1')

  // Удаляем лишние слеши и пустые сегменты
  path = path
    .split('/')
    .filter(segment => segment !== '')
    .join('/')

  return '/' + path
}

export function generateRouteFunction(route) {
  const params = []
  const pathSegments = route.split('/')
  const optionalParams = new Set()

  for (const segment of pathSegments) {
    if (segment.startsWith(':')) {
      const paramName = segment.slice(1)
      params.push(paramName)
    } else if (segment.startsWith('[...')) {
      const paramName = segment.slice(4, -1)
      if (paramName.endsWith('?')) {
        const cleanParamName = paramName.slice(0, -1)
        params.push(cleanParamName)
        optionalParams.add(cleanParamName)
      } else {
        params.push(paramName)
      }
    }
  }

  const pathParamsType = params
    .map(param => {
      const isOptional = optionalParams.has(param)
      const type = param.startsWith('...') ? 'string[]' : 'string | number'
      return `${param}${isOptional ? '?' : ''}: ${type}`
    })
    .join(', ')

  const paramsType = pathParamsType
    ? `{ path: { ${pathParamsType} }, query?: Record<string, string | number | boolean> }`
    : `{ query?: Record<string, string | number | boolean> } | void`

  const baseUrl = route.replace(/:[^/]+|\[\.\.\.[^\]]+\]/g, match => {
    if (match.startsWith('[...')) {
      const paramName = match.slice(4, -1)
      return `\${params?.path?.${paramName.replace('?', '')}}`
    }
    return `\${params?.path?.${match.slice(1)}}`
  })

  if (!pathParamsType) {
    return `(params?: ${paramsType}) => {
      if (!params) return '${route}'
      return \`${route}\${generateQueryString(params?.query)}\`
    }`
  }

  return `(params: ${paramsType}) => {
    return \`${baseUrl}\${generateQueryString(params.query)}\`
  }`
}

export function generateRoutesFile(routes) {
  const routeEntries = routes
    .map(route => {
      const functionBody = generateRouteFunction(route)
      return `  '${route}': ${functionBody}`
    })
    .join(',\n')

  return `// This file is auto-generated by scripts/generate-routes.mjs
// Do not edit this file directly

function generateQueryString(query?: Record<string, string | number | boolean>) {
  if (!query) return ''
  const searchParams = new URLSearchParams()
  Object.entries(query).forEach(([key, value]) => {
    if (value !== undefined && value !== null) {
      searchParams.append(key, String(value))
    }
  })
  const queryString = searchParams.toString()
  return queryString ? '?' + queryString : ''
}

export const routes = {
${routeEntries}
} as const

export type Routes = typeof routes

export type Route = keyof Routes
`
}

async function main() {
  try {
    const routes = await scanDirectory(APP_DIR)
    const routesFileContent = generateRoutesFile(routes)
    await fs.writeFile(OUTPUT_FILE, routesFileContent)
    console.log(`Маршруты успешно сгенерированы в ${OUTPUT_FILE}`)
  } catch (error) {
    console.error('Ошибка при генерации маршрутов:', error)
  }
}

main()
